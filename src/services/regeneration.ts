import type { Conversation } from '../types/conversation'
import type { Job } from '../types/job'
import type { SectionAnalysis } from '../types/regeneration'

export interface RegenerationConfig {
  minimumWordCount: number
  maxAutoRegenerationAttempts: number
  regenerationCooldownMs: number
}

export const DEFAULT_REGENERATION_CONFIG: RegenerationConfig = {
  minimumWordCount: 100,
  maxAutoRegenerationAttempts: 3,
  regenerationCooldownMs: 5000
}

/**
 * Pure function to count words in text content
 */
export function countWords(content: string): number {
  if (!content?.trim()) return 0
  return content.trim().split(/\s+/).length
}

/**
 * Pure function to create section key for tracking
 */
export function createSectionKey(scriptId: string, sectionId: string): string {
  return `${scriptId}:${sectionId}`
}

/**
 * Pure function to count regeneration attempts from conversation history
 * Looks through message history to find regeneration requests for a section
 */
export function countRegenerationAttempts(conversation: Conversation, sectionId: string): number {
  // Count how many times this section was regenerated by looking at message patterns
  // This is a simple heuristic - in a real app you might store this metadata differently
  const regenerationMessages = conversation.messages.filter(msg => 
    msg.role === 'user' && 
    msg.content.toLowerCase().includes('regenerate') &&
    msg.content.includes(sectionId)
  )
  
  return regenerationMessages.length
}

/**
 * Pure function to determine if a section needs regeneration
 */
export function doesSectionNeedRegeneration(
  section: { id: string; title: string; content?: string; status?: string },
  config: RegenerationConfig,
  attemptCount: number
): { needsRegeneration: boolean; reason?: string } {
  
  // Don't regenerate if section is not completed
  if (section.status !== 'completed') {
    return { needsRegeneration: false, reason: 'section_not_completed' }
  }

  // Don't regenerate if we've exceeded max attempts
  if (attemptCount >= config.maxAutoRegenerationAttempts) {
    return { needsRegeneration: false, reason: 'max_attempts_reached' }
  }

  // Check word count
  const wordCount = countWords(section.content || '')
  if (wordCount < config.minimumWordCount) {
    return { needsRegeneration: true, reason: 'insufficient_word_count' }
  }

  return { needsRegeneration: false, reason: 'sufficient_length' }
}

/**
 * Pure function to analyze all sections in a conversation
 */
export function analyzeSections(
  conversation: Conversation,
  config: RegenerationConfig,
  existingJobs: Job[] = []
): SectionAnalysis[] {
  
  return conversation.sections.map(section => {
    const attemptCount = countRegenerationAttempts(conversation, section.id)
    const wordCount = countWords(section.content || '')
    const regenerationCheck = doesSectionNeedRegeneration(section, config, attemptCount)
    
    // Don't regenerate if there's already a job running for this section
    const hasActiveJob = existingJobs.some(job => 
      job.type === 'regenerate-section' && 
      job.sectionId === section.id && 
      (job.status === 'processing' || job.status === 'queued')
    )

    return {
      sectionId: section.id,
      sectionTitle: section.title,
      wordCount,
      needsRegeneration: regenerationCheck.needsRegeneration && !hasActiveJob,
      reason: hasActiveJob ? 'job_already_running' : regenerationCheck.reason,
      attempts: attemptCount,
      isInCooldown: false // We can implement cooldown logic here if needed
    }
  })
}

/**
 * Pure function to get sections that need regeneration, sorted by priority
 */
export function getSectionsNeedingRegeneration(
  conversation: Conversation,
  config: RegenerationConfig,
  existingJobs: Job[] = []
): SectionAnalysis[] {
  const analysis = analyzeSections(conversation, config, existingJobs)
  
  return analysis
    .filter(section => section.needsRegeneration)
    .sort((a, b) => {
      // Sort by order in conversation to maintain sequence
      const aIndex = conversation.sections.findIndex(s => s.id === a.sectionId)
      const bIndex = conversation.sections.findIndex(s => s.id === b.sectionId)
      return aIndex - bIndex
    })
}

/**
 * Pure function to get the next section to regenerate (first one in sequence)
 */
export function getNextSectionToRegenerate(
  conversation: Conversation,
  config: RegenerationConfig,
  existingJobs: Job[] = []
): SectionAnalysis | null {
  const sectionsToRegenerate = getSectionsNeedingRegeneration(conversation, config, existingJobs)
  return sectionsToRegenerate[0] || null
}